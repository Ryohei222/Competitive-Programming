{
/*
	// Place your snippets for C++ here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Print to console": {
		"prefix": "log",
		"body": [
			"console.log('$1');",
			"$2"
		],
		"description": "Log output to console"
	}
*/
"SegmentTree": {
	"prefix": "segment",
	"body": [
		"template< typename Monoid >",
		"struct SegmentTree",
		"{",
		"  using F = function< Monoid(Monoid, Monoid) >;",
		" ",
		"  int sz;",
		"  vector< Monoid > seg;",
		" ",
		"  const F f;",
		"  const Monoid M1;",
		" ",
		"  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)",
		"  {",
		"    sz = 1;",
		"    while(sz < n) sz <<= 1;",
		"    seg.assign(2 * sz, M1);",
		"  }",
		" ",
		"  void set(int k, const Monoid &x)",
		"  {",
		"    seg[k + sz] = x;",
		"  }",
		" ",
		"  void build()",
		"  {",
		"    for(int k = sz - 1; k > 0; k--) {",
		"      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
		"    }",
		"  }",
		" ",
		"  void update(int k, const Monoid &x)",
		"  {",
		"    k += sz;",
		"    seg[k] = x;",
		"    while(k >>= 1) {",
		"      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
		"    }",
		"  }",
		" ",
		"  Monoid query(int a, int b)",
		"  {",
		"    Monoid L = M1, R = M1;",
		"    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {",
		"      if(a & 1) L = f(L, seg[a++]);",
		"      if(b & 1) R = f(seg[--b], R);",
		"    }",
		"    return f(L, R);",
		"  }",
		"};",
	],
	"description": "Paste Segment-Tree"
},
"LazySegmentTree": {
	"prefix": "lazysegment",
	"body": [
		"template< typename Monoid, typename OperatorMonoid = Monoid >",
		"struct LazySegmentTree",
		"{",
		"  using F = function< Monoid(Monoid, Monoid) >;",
		"  using G = function< Monoid(Monoid, OperatorMonoid) >;",
		"  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;",
		"  using P = function< OperatorMonoid(OperatorMonoid, int) >;",
		"",
		"  int sz;",
		"  vector< Monoid > data;",
		"  vector< OperatorMonoid > lazy;",
		"  const F f;",
		"  const G g;",
		"  const H h;",
		"  const P p;",
		"  const Monoid M1;",
		"  const OperatorMonoid OM0;",
		"",
		"",
		"  LazySegmentTree(int n, const F f, const G g, const H h, const P p,",
		"                  const Monoid &M1, const OperatorMonoid OM0)",
		"      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)",
		"  {",
		"    sz = 1;",
		"    while(sz < n) sz <<= 1;",
		"    data.assign(2 * sz, M1);",
		"    lazy.assign(2 * sz, OM0);",
		"  }",
		"",
		"  void set(int k, const Monoid &x)",
		"  {",
		"    data[k + sz] = x;",
		"  }",
		"",
		"  void build()",
		"  {",
		"    for(int k = sz - 1; k > 0; k--) {",
		"      data[k] = f(data[2 * k + 0], data[2 * k + 1]);",
		"    }",
		"  }",
		"",
		"  void propagate(int k, int len)",
		"  {",
		"    if(lazy[k] != OM0) {",
		"      if(k < sz) {",
		"        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);",
		"        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);",
		"      }",
		"      data[k] = g(data[k], p(lazy[k], len));",
		"      lazy[k] = OM0;",
		"    }",
		"  }",
		"",
		"  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)",
		"  {",
		"    propagate(k, r - l);",
		"    if(r <= a || b <= l) {",
		"      return data[k];",
		"    } else if(a <= l && r <= b) {",
		"      lazy[k] = h(lazy[k], x);",
		"      propagate(k, r - l);",
		"      return data[k];",
		"    } else {",
		"      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),",
		"                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));",
		"    }",
		"  }",
		"",
		"  Monoid update(int a, int b, const OperatorMonoid &x)",
		"  {",
		"    return update(a, b, x, 1, 0, sz);",
		"  }",
		"",
		"",
		"  Monoid query(int a, int b, int k, int l, int r)",
		"  {",
		"    propagate(k, r - l);",
		"    if(r <= a || b <= l) {",
		"      return M1;",
		"    } else if(a <= l && r <= b) {",
		"      return data[k];",
		"    } else {",
		"      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),",
		"               query(a, b, 2 * k + 1, (l + r) >> 1, r));",
		"    }",
		"  }",
		"",
		"  Monoid query(int a, int b)",
		"  {",
		"    return query(a, b, 1, 0, sz);",
		"  }",
		"",
		"  Monoid operator[](const int &k)",
		"  {",
		"    return query(k, k + 1);",
		"  }",
		"};",
	],
	"description": "Paste Lazy-Segment-Tree"
},
"Include-macro": {
	"prefix": "macro",
	"body": [
		"#include <iostream>",
		"#include <algorithm>",
		"#include <functional>",
		"#include <string>",
		"#include <vector>",
		"#include <set>",
		"#include <queue>",
		"#include <stack>",
		"#include <numeric>",
		"#include <bitset>",
		"#inlclude <map>",
		"#include <set>",
		"#include <unordered_set>",
		"#include <unordered_map>",
		" ",
		"using namespace std;",
		" ",
		"typedef long long ll;",
		"typedef pair<int, int> P;",
		"static const int INF = 1000010000;",
		"static const int MOD = 1000000007;",
		" ",
		"#define FOR(i, a, b) for(int i = (a); i < (b); ++i)",
		"#define REP(i, n) for(int i = 0; i < (n); ++i)",
		"#define SORT(v) sort(v.begin(), v.end());",
		"#define pb push_back",
		"#define mp make_pair",
		"#define np next_permutation",
		"#define pq priority_queue",
		"",
		"//int dx4[4] = {0,1,0,-1}, dy4[4] = {-1,0,1,0};",
		"//int dx5[5] = {-1,0,0,0,1}, dy5[5] = {0,-1,0,1,0};",
		"//int dx8[8] = {-1,0,1,1,1,0,-1,-1}, dy8[8] = {1,1,1,0,-1,-1,-1,0};",
		"//int dx9[9] = {-1,0,1,1,1,0,-1,-1,0}, dy9[9] = {1,1,1,0,-1,-1,-1,0,0};",
	],
	"description": "Paste Include macro"
},
"BIT": {
	"prefix": "BIT",
	"body": [
		"template< class T >",
		"struct BinaryIndexedTree",
		"{",
		"  vector< T > data;",
		"",
		"  BinaryIndexedTree(int sz)",
		"  {",
		"    data.assign(++sz, 0);",
		"  }",
		"",
		"  T sum(int k)",
		"  {",
		"    T ret = 0;",
		"    for(++k; k > 0; k -= k & -k) ret += data[k];",
		"    return (ret);",
		"  }",
		"",
		"  void add(int k, T x)",
		"  {",
		"    for(++k; k < data.size(); k += k & -k) data[k] += x;",
		"  }",
		"};",
	],
	"description": "Paste Binary-Indexed-Tree"
},
"Grid-BFS": {
	"prefix": "bfs",
	"body": [
		"int W, H;",
		"char mas[500][500];",
		"int min_cost[500][500];",
		" ",
		"int bfs(int sx, int sy, char c)",
		"{",
		"  const int vx[] = {0, 1, 0, -1}, vy[] = {1, 0, -1, 0};",
		"  memset(min_cost, -1, sizeof(min_cost));",
		"   ",
		"  queue< pair< int, int > > que;",
		"  que.emplace(sx, sy);",
		"  min_cost[sx][sy] = 0;",
		" ",
		"  while(!que.empty()) {",
		"    auto p = que.front(); que.pop();",
		"    if(mas[p.second][p.first] == c) return(min_cost[p.first][p.second]);",
		"    for(int i = 0; i < 4; i++) {",
		"      int nx = p.first + vx[i], ny = p.second + vy[i];",
		"      if(nx < 0 || ny < 0 || nx >= W || ny >= H) continue;",
		"      if(min_cost[nx][ny] != -1) continue;",
		"      if(mas[ny][nx] == '#') continue;",
		"      min_cost[nx][ny] = min_cost[p.first][p.second] + 1;",
		"      que.emplace(nx, ny);",
		"    }",
		"  }",
		"  return(-1);",
		"}",
	],
	"description": "Paste Grid-BFS"
},
"Dijkstra": {
	"prefix": "dijkstra",
	"body": [
		"template< typename T >",
		"vector< T > dijkstra(WeightedGraph< T > &g, int s)",
		"{",
		"  const auto INF = numeric_limits< T >::max();",
		"  vector< T > dist(g.size(), INF);",
		"",
		"  using Pi = pair< T, int >;",
		"  priority_queue< Pi, vector< Pi >, greater< Pi > > que;",
		"  dist[s] = 0;",
		"  que.emplace(dist[s], s);",
		"  while(!que.empty()) {",
		"    T cost;",
		"    int idx;",
		"    tie(cost, idx) = que.top();",
		"    que.pop();",
		"    if(dist[idx] < cost) continue;",
		"    for(auto &e : g[idx]) {",
		"      auto next_cost = cost + e.cost;",
		"      if(dist[e.to] <= next_cost) continue;",
		"      dist[e.to] = next_cost;",
		"      que.emplace(dist[e.to], e.to);",
		"    }",
		"  }",
		"  return dist;",
		"}",
	],
	"description": "Paste Dijkstra"
},
"bellman_ford": {
	"prefix": "bellman",
	"body": [
		"template< typename T >",
		"vector< T > bellman_ford(Edges< T > &edges, int V, int s)",
		"{",
		"  const auto INF = numeric_limits< T >::max();",
		"  vector< T > dist(V, INF);",
		"  dist[s] = 0;",
		"  for(int i = 0; i < V - 1; i++) {",
		"    for(auto &e : edges) {",
		"      if(dist[e.src] == INF) continue;",
		"      dist[e.to] = min(dist[e.to], dist[e.src] + e.cost);",
		"    }",
		"  }",
		"  for(auto &e : edges) {",
		"    if(dist[e.src] == INF) continue;",
		"    if(dist[e.src] + e.cost < dist[e.to]) return vector< T >();",
		"  }",
		"  return dist;",
		"}",
	],
	"description": "Paste Bellman-Ford"
},
"Warshall-Floyd": {
	"prefix": "warshall",
	"body": [
		"templete< typename T = int >",
		"void warshall_floyd(Matrix< T > &g)",
		"{",
		"  for(int k = 0; k < g.size(); k++) {",
		"    for(int i = 0; i < g.size(); i++) {",
		"      for(int j = 0; j < g.size(); j++) {",
		"        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);",
		"      }",
		"    }",
		"  }",
		"}",
	],
	"description": "Paste Warshall-Floyd"
},
"Prime-Tree": {
	"prefix": "prim",
	"body": [
		"template< typename T >",
		"T prim(WeightedGraph< T > &g)",
		"{",
		"  using Pi = pair< T, int >;",
		"",
		"  T total = 0;",
		"  vector< bool > used(g.size(), false);",
		"  priority_queue< Pi, vector< Pi >, greater< Pi > > que;",
		"  que.emplace(0, 0);",
		"  while(!que.empty()) {",
		"    Pi p = que.top();",
		"    que.pop();",
		"    if(used[p.second]) continue;",
		"    used[p.second] = true;",
		"    total += p.first;",
		"    for(auto &e : g[p.second]) {",
		"      que.emplace(e.cost, e.to);",
		"    }",
		"  }",
		"  return (total);",
		"}",
	],
	"description": "Paste Prim-Tree"
},
"Kruskal-Tree": {
	"prefix": "kruskal",
	"body": [
		"template< typename T >",
		"T kruskal(Edges< T > &edges, int V)",
		"{",
		"  sort(begin(edges), end(edges), [](const edge< T > &a, const edge< T > &b)",
		"  {",
		"    return (a.cost < b.cost);",
		"  });",
		"  UnionFind tree(V);",
		"  T ret = 0;",
		"  for(auto &e : edges) {",
		"    if(tree.unite(e.src, e.to)) ret += e.cost;",
		"  }",
		"  return (ret);",
		"}",
	],
	"description": "Paste Kruskal-Tree(requires Union-Find)"
},
"Union-Find": {
	"prefix": "unionfind",
	"body": [
		"struct UnionFind",
		"{",
		"  vector< int > data;",
		"",
		"  UnionFind(int sz)",
		"  {",
		"    data.assign(sz, -1);",
		"  }",
		"",
		"  bool unite(int x, int y)",
		"  {",
		"    x = find(x), y = find(y);",
		"    if(x == y) return(false);",
		"    if(data[x] > data[y]) swap(x, y);",
		"    data[x] += data[y];",
		"    data[y] = x;",
		"    return(true);",
		"  }",
		"",
		"  int find(int k)",
		"  {",
		"    if(data[k] < 0) return(k);",
		"    return(data[k] = find(data[k]));",
		"  }",
		"",
		"  int size(int k)",
		"  {",
		"    return(-data[find(k)]);",
		"  }",
		"};",
	],
	"description": "Paste Union-Find"
},
"Chu-Liu": {
	"prefix": "chuliu",
	"body": [
		"template< typename T >",
		"struct MinimumSpanningTreeArborescence",
		"{",
		"  using Pi = pair< T, int >;",
		"  using Heap = SkewHeap< Pi, int >;",
		"  using Node = typename Heap::Node;",
		"  const Edges< T > &es;",
		"  const int V;",
		"  T INF;",
		" ",
		"  MinimumSpanningTreeArborescence(const Edges< T > &es, int V) :",
		"      INF(numeric_limits< T >::max()), es(es), V(V) {}",
		" ",
		"  T build(int start)",
		"  {",
		"    auto g = [](const Pi &a, const T &b) { return Pi(a.first + b, a.second); };",
		"    auto h = [](const T &a, const T &b) { return a + b; };",
		"    Heap heap(g, h);",
		"    vector< Node * > heaps(V, heap.makeheap());",
		"    for(auto &e : es) heap.push(heaps[e.to], {e.cost, e.src});",
		"    UnionFind uf(V);",
		"    vector< int > used(V, -1);",
		"    used[start] = start;",
		" ",
		"    T ret = 0;",
		"    for(int s = 0; s < V; s++) {",
		"      stack< int > path;",
		"      for(int u = s; used[u] < 0;) {",
		"        path.push(u);",
		"        used[u] = s;",
		"        if(heap.empty(heaps[u])) return -1;",
		"        auto p = heap.top(heaps[u]);",
		"        ret += p.first;",
		"        heap.add(heaps[u], -p.first);",
		"        heap.pop(heaps[u]);",
		"        int v = uf.find(p.second);",
		"        if(used[v] == s) {",
		"          int w;",
		"          Node *nextheap = heap.makeheap();",
		"          do {",
		"            w = path.top();",
		"            path.pop();",
		"            nextheap = heap.merge(nextheap, heaps[w]);",
		"          } while(uf.unite(v, w));",
		"          heaps[uf.find(v)] = nextheap;",
		"          used[uf.find(v)] = -1;",
		"        }",
		"        u = uf.find(v);",
		"      }",
		"    }",
		"    return ret;",
		"  }",
		"}; ",
	],
	"description": "Paste Chu-Liu(requires Skew-Heap)(Minimum-Spanning-Tree-Arborescence)"
},
"Skew-Heap": {
	"prefix": "skewheap",
	"body": [
		"template< typename T, typename E = T >",
		"struct SkewHeap",
		"{",
		"  using G = function< T(T, E) >;",
		"  using H = function< E(E, E) >;",
		"",
		"  struct Node",
		"  {",
		"    T key;",
		"    E lazy;",
		"    Node *l, *r;",
		"  };",
		"",
		"  const bool rev;",
		"  const G g;",
		"  const H h;",
		"",
		"  SkewHeap(bool rev = false) : g([](const T &a, const E &b) { return a + b; }),",
		"                               h([](const E &a, const E &b) { return a + b; }), rev(rev) {}",
		"",
		"  SkewHeap(const G &g, const H &h, bool rev = false) : g(g), h(h), rev(rev) {}",
		"",
		"  Node *propagate(Node *t)",
		"  {",
		"    if(t->lazy != 0) {",
		"      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);",
		"      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);",
		"      t->key = g(t->key, t->lazy);",
		"      t->lazy = 0;",
		"    }",
		"    return t;",
		"  }",
		"",
		"  Node *merge(Node *x, Node *y)",
		"  {",
		"    if(!x || !y) return x ? x : y;",
		"    propagate(x), propagate(y);",
		"    if((x->key > y->key) ^ rev) swap(x, y);",
		"    x->r = merge(y, x->r);",
		"    swap(x->l, x->r);",
		"    return x;",
		"  }",
		"",
		"  void push(Node *&root, const T &key)",
		"  {",
		"    root = merge(root, new Node({key, 0, nullptr, nullptr}));",
		"  }",
		"",
		"  T top(Node *root)",
		"  {",
		"    return propagate(root)->key;",
		"  }",
		"",
		"  void pop(Node *&root)",
		"  {",
		"    propagate(root);",
		"    auto *temp = root;",
		"    root = merge(root->l, root->r);",
		"    delete temp;",
		"  }",
		"",
		"  bool empty(Node *root) const",
		"  {",
		"    return !root;",
		"  }",
		"",
		"  void add(Node *root, const E &lazy)",
		"  {",
		"    if(root) {",
		"      root->lazy = h(root->lazy, lazy);",
		"      propagate(root);",
		"    }",
		"  }",
		"",
		"  Node *makeheap()",
		"  {",
		"    return nullptr;",
		"  }",
		"};",
	],
	"description": "Skew-Heap"
},
"Dinic": {
	"prefix": "dinic",
	"body": [
		"template< typename T >",
		"struct Dinic",
		"{",
		"  struct edge",
		"  {",
		"    int to;",
		"    T cap;",
		"    int rev;",
		"  };",
		"",
		"  const T INF;",
		"  vector< vector< edge > > graph;",
		"  vector< T > min_cost;",
		"  vector< int > iter;",
		"",
		"  Dinic(int n) : INF(numeric_limits< T >::max())",
		"  {",
		"    graph.resize(n);",
		"  }",
		"",
		"  void add_edge(int from, int to, T cap)",
		"  {",
		"    graph[from].push_back((edge) {to, cap, (int) graph[to].size()});",
		"    graph[to].push_back((edge) {from, 0, (int) graph[from].size() - 1});",
		"  }",
		"",
		"  bool bfs(int s, int t)",
		"  {",
		"    min_cost.assign(graph.size(), -1);",
		"    queue< int > que;",
		"    min_cost[s] = 0;",
		"    que.push(s);",
		"    while(!que.empty()) {",
		"      int p = que.front();",
		"      que.pop();",
		"      for(auto &e : graph[p]) {",
		"        if(e.cap > 0 && min_cost[e.to] == -1) {",
		"          min_cost[e.to] = min_cost[p] + 1;",
		"          que.push(e.to);",
		"        }",
		"      }",
		"    }",
		"    return (min_cost[t] != -1);",
		"  }",
		"",
		"  T dfs(int idx, const int t, T flow)",
		"  {",
		"    if(idx == t) return (flow);",
		"    for(int &i = iter[idx]; i < graph[idx].size(); i++) {",
		"      edge &e = graph[idx][i];",
		"      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {",
		"        T d = dfs(e.to, t, min(flow, e.cap));",
		"        if(d > 0) {",
		"          e.cap -= d;",
		"          graph[e.to][e.rev].cap += d;",
		"          return (d);",
		"        }",
		"      }",
		"    }",
		"    return (0);",
		"  }",
		"",
		"  T max_flow(int s, int t)",
		"  {",
		"    T flow = 0;",
		"    while(bfs(s, t)) {",
		"      iter.assign(graph.size(), 0);",
		"      T f = 0;",
		"      while((f = dfs(s, t, INF)) > 0) {",
		"        flow += f;",
		"      }",
		"    }",
		"    return (flow);",
		"  }",
		"};",
	],
	"description": "Paste Dinic"
},
"Bipartite-Matching": {
	"prefix": "matching",
	"body": [
		"struct Bipartite_Matching",
		"{",
		"  vector< vector< int > > graph;",
		"  vector< int > match, alive, used;",
		"  int timestamp;",
		" ",
		"  Bipartite_Matching(int n)",
		"  {",
		"    timestamp = 0;",
		"    graph.resize(n);",
		"    alive.assign(n, 1);",
		"    used.assign(n, 0);",
		"    match.assign(n, -1);",
		"  }",
		" ",
		"  void add_edge(int u, int v)",
		"  {",
		"    graph[u].push_back(v);",
		"    graph[v].push_back(u);",
		"  }",
		" ",
		"  bool dfs(int v)",
		"  {",
		"    used[v] = timestamp;",
		"    for(int i = 0; i < graph[v].size(); i++) {",
		"      int u = graph[v][i], w = match[u];",
		"      if(alive[u] == 0) continue;",
		"      if(w == -1 || (used[w] != timestamp && dfs(w))) {",
		"        match[v] = u;",
		"        match[u] = v;",
		"        return (true);",
		"      }",
		"    }",
		"    return (false);",
		"  }",
		" ",
		"  int bipartite_matching()",
		"  {",
		"    int ret = 0;",
		"    for(int i = 0; i < graph.size(); i++) {",
		"      if(alive[i] == 0) continue;",
		"      if(match[i] == -1) {",
		"        ++timestamp;",
		"        ret += dfs(i);",
		"      }",
		"    }",
		"    return (ret);",
		"  } ",
		"};",
	],
	"description": "Paste Bipartite-Matching"
},
}